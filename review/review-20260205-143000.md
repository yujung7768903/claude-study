# 복습 퀴즈 (2026-02-05)

출제 범위: mock-execution-flow.md, atomic-integer.md, jackson-deserialization-without-setter.md, mockito-argument-captor.md, uri-url-encoding-and-resttemplate.md

---

### Q1. [객관식] (출처: mock-execution-flow.md)
Mockito의 Stubbing이란 무엇인가요?

A) Mock 객체의 내부 로직을 실제로 실행하는 것
B) Mock 객체의 동작을 미리 정의하는 것
C) Mock 객체의 호출 기록을 저장하는 것
D) Mock 객체를 바이트코드로 변환하는 것

<details>
<summary>정답 보기</summary>

**정답: B) Mock 객체의 동작을 미리 정의하는 것**

Stubbing은 `when().thenReturn()`을 사용하여 "이 메서드가 호출되면 이 값을 반환하라"고 미리 설정하는 것입니다. Mock 객체에게 "대본"을 써주는 것과 같습니다. 실제 로직 실행 없이 원하는 값만 반환하게 만들어 테스트를 빠르고 예측 가능하게 만듭니다.
</details>

---

### Q2. [주관식 - 빈칸] (출처: atomic-integer.md)
`AtomicInteger`는 내부적으로 ________ 연산을 사용하여 `synchronized` 없이도 원자적 연산을 보장합니다.

<details>
<summary>정답 보기</summary>

**정답: `CAS` (Compare-And-Swap)**

CAS는 "현재 값이 예상 값과 같으면 새 값으로 교체"하는 연산으로, CPU 레벨의 단일 명령어로 수행되므로 lock 없이 빠릅니다. 메모리에서 값을 읽고, 새 값을 계산한 후, 여전히 예상 값이면 교체하고, 아니면 재시도합니다.
</details>

---

### Q3. [객관식] (출처: jackson-deserialization-without-setter.md)
`@Getter`만 있고 `@Setter`가 없는 클래스에 Jackson이 JSON 데이터를 역직렬화할 수 있는 이유는?

A) @Getter가 내부적으로 Setter 역할도 하기 때문
B) Jackson이 리플렉션으로 private 필드에 직접 접근하기 때문
C) Spring Boot가 자동으로 Setter를 생성해주기 때문
D) JSON 파싱 시 Getter만 있으면 충분하기 때문

<details>
<summary>정답 보기</summary>

**정답: B) Jackson이 리플렉션으로 private 필드에 직접 접근하기 때문**

Jackson은 `Field.setAccessible(true)`를 사용하여 private 필드에도 접근할 수 있습니다. Setter가 없어도 리플렉션을 통해 필드에 직접 값을 주입합니다. 단, `@NoArgsConstructor`로 기본 생성자는 반드시 필요합니다.
</details>

---

### Q4. [주관식 - 코드] (출처: mock-execution-flow.md)
Mock 객체가 호출 기록을 저장하는 시점은 언제인가요? (stubbing 모드 / 실제 호출 시 / verification 모드 중 선택하고 설명하세요)

<details>
<summary>정답 보기</summary>

**정답: 실제 호출 시**

Mock 메서드가 실제로 호출될 때 MockHandler가 Invocation 객체를 생성하고 invocationContainer에 저장합니다. stubbing 모드(`when()` 실행 시)에는 호출 기록을 저장하지 않고 InvocationMatcher만 생성합니다. verification 모드(`verify()` 실행 시)에는 이미 저장된 기록을 조회만 합니다.

```
실제 호출 시: MockHandler.handle() → Invocation 생성 → invocations.add()
```
</details>

---

### Q5. [객관식] (출처: mockito-argument-captor.md)
ArgumentCaptor의 `capture()` 메서드가 실제로 인자를 캡처하는 시점은?

A) Mock 메서드가 호출되는 순간
B) ArgumentCaptor 객체를 생성하는 순간
C) verify() 실행 시점에 저장된 기록에서 꺼내올 때
D) getValue()를 호출하는 순간

<details>
<summary>정답 보기</summary>

**정답: C) verify() 실행 시점에 저장된 기록에서 꺼내올 때**

ArgumentCaptor는 "인자가 전달되는 순간"에 캡처하는 것이 아니라, `verify()` 실행 시점에 이미 Mock에 저장된 호출 기록에서 인자를 꺼내서 Captor에 복사합니다. 마치 CCTV 영상을 나중에 재생하여 특정 프레임을 캡처하는 것과 같습니다.
</details>

---

### Q6. [주관식 - 빈칸] (출처: uri-url-encoding-and-resttemplate.md)
`java.net.URI`는 RFC 3986 기반으로 공백을 ______로 인코딩하지만, `URLEncoder.encode()`는 공백을 ______로 변환합니다.

<details>
<summary>정답 보기</summary>

**정답: `%20`, `+`**

`java.net.URI`는 RFC 3986 표준을 따라 공백을 `%20`으로 인코딩합니다. 반면 `URLEncoder.encode()`는 `application/x-www-form-urlencoded` 형식을 따르므로 공백을 `+`로 변환합니다.
</details>

---

### Q7. [객관식] (출처: atomic-integer.md)
Stream lambda에서 인덱스 카운터로 `AtomicInteger`를 사용하는 주된 이유는?

A) thread-safety를 보장하기 위해
B) lambda 안에서 외부 변수를 변경할 때 effectively final 제약을 우회하기 위해
C) int보다 성능이 좋아서
D) Stream API가 AtomicInteger만 지원해서

<details>
<summary>정답 보기</summary>

**정답: B) lambda 안에서 외부 변수를 변경할 때 effectively final 제약을 우회하기 위해**

순차 스트림에서는 사실 thread-safety가 필요하지 않지만, lambda 안에서 외부 변수를 변경하려면 `int`는 effectively final 제약으로 사용할 수 없습니다. `AtomicInteger`는 객체 참조는 final이지만 내부 값은 변경 가능하므로 이 제약을 우회할 수 있습니다.

```java
// 불가능
int index = 0;
list.stream().map(item -> process(item, index++)); // 컴파일 에러

// 가능
AtomicInteger index = new AtomicInteger(0);
list.stream().map(item -> process(item, index.getAndIncrement())); // OK
```
</details>

---

### Q8. [주관식 - 코드] (출처: jackson-deserialization-without-setter.md)
Jackson 역직렬화가 실패할 때 체크해야 할 첫 번째 필수 조건은 무엇인가요?

<details>
<summary>정답 보기</summary>

**정답: 기본 생성자(no-args constructor)가 있는지 확인**

Jackson은 역직렬화 시 먼저 기본 생성자로 객체를 생성한 후 필드에 값을 주입합니다. 기본 생성자가 없으면 "No suitable constructor found for type" 에러가 발생합니다.

```java
@NoArgsConstructor  // 필수!
public class MyDto {
    private String name;
}
```

기본 생성자가 없는 경우:
- `@NoArgsConstructor` 추가
- 또는 `@JsonCreator`로 생성자 지정
</details>

---

### Q9. [객관식] (출처: mock-execution-flow.md)
Mock 메서드가 실제로 호출될 때 일어나지 않는 것은?

A) 메서드 호출을 받음
B) 전달된 인자를 저장함
C) 메서드 내부 로직을 실행함
D) when-thenReturn에서 지정한 값을 반환함

<details>
<summary>정답 보기</summary>

**정답: C) 메서드 내부 로직을 실행함**

Mock 메서드는 메서드 호출을 받고, 인자를 저장하며, stubbing에서 지정한 값을 반환하지만, **메서드의 내부 로직은 실행하지 않습니다**. 예를 들어 RestTemplate의 exchange()가 Mock이면 실제 HTTP 요청을 보내지 않습니다. 이것이 Mock이 "가짜 객체"인 핵심 이유입니다.
</details>

---

### Q10. [주관식 - 코드] (출처: uri-url-encoding-and-resttemplate.md)
RestTemplate에서 이미 인코딩된 파라미터 값을 전달할 때 이중 인코딩을 방지하려면 어떤 방식을 사용해야 하나요?

<details>
<summary>정답 보기</summary>

**정답: `UriComponentsBuilder`와 `build(true)` 사용**

Map 방식은 RestTemplate이 자동으로 인코딩하므로 이미 인코딩된 값이 있으면 이중 인코딩(`%20` → `%2520`)이 발생합니다.

```java
// 이중 인코딩 방지
URI uri = UriComponentsBuilder
    .fromHttpUrl("http://example.com/api")
    .queryParam("name", alreadyEncodedValue)
    .build(true)  // true: 이미 인코딩된 값 그대로 사용
    .toUri();

restTemplate.exchange(uri, ...);
```

또는 `encode()` 메서드로 인코딩 시점을 명시적으로 제어할 수 있습니다:
```java
.build().encode().toUri()
```
</details>

---

## 학습 마무리

총 10문제를 풀어보셨습니다. 틀린 문제가 있다면 해당 학습 자료를 다시 복습해보세요!

- mock-execution-flow.md: Stubbing, Mock 동작 원리
- atomic-integer.md: CAS, thread-safety
- jackson-deserialization-without-setter.md: 리플렉션 기반 역직렬화
- mockito-argument-captor.md: 인자 캡처 원리
- uri-url-encoding-and-resttemplate.md: URI 인코딩 차이
