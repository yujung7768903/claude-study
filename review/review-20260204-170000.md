# 복습 퀴즈 (2026-02-04)

출제 범위: uri-url-encoding-and-resttemplate.md, java-stream-creation.md, atomic-integer.md

---

### Q1. [객관식] (출처: atomic-integer.md)
`count++` 연산이 멀티스레드에서 안전하지 않은 이유는?

A) `count++`는 컴파일 에러가 발생하기 때문
B) 읽기 → 증가 → 쓰기 3단계 연산이라 중간에 다른 스레드가 개입할 수 있기 때문
C) `int` 타입은 volatile이 아니기 때문
D) JVM이 `++` 연산을 지원하지 않기 때문

<details>
<summary>정답 보기</summary>

**정답: B)**

`count++`는 단일 연산처럼 보이지만 실제로는 (1) 메모리에서 값 읽기 (2) 값 증가 (3) 메모리에 쓰기의 3단계로 수행됩니다. 이 사이에 다른 스레드가 끼어들면 값이 유실되는 race condition이 발생합니다.
</details>

---

### Q2. [주관식 - 빈칸] (출처: uri-url-encoding-and-resttemplate.md)
RestTemplate에서 Map 방식으로 String URL을 전달할 때, 값에 이미 인코딩된 `%20`이 포함되어 있으면 `______`으로 변환되는 이중 인코딩 문제가 발생할 수 있다.

<details>
<summary>정답 보기</summary>

**정답: `%2520`**

RestTemplate 내부에서 자동 인코딩을 수행하기 때문에, 이미 인코딩된 `%`가 다시 `%25`로 인코딩되어 `%2520`이 됩니다. 이를 방지하려면 `UriComponentsBuilder`의 `build(true)`를 사용해야 합니다.
</details>

---

### Q3. [객관식] (출처: java-stream-creation.md)
`int[] nums = {1, 2, 3};`에서 `IntStream`을 올바르게 얻는 방법은?

A) `Stream.of(nums)`
B) `Arrays.stream(nums)`
C) `nums.stream()`
D) `StreamSupport.stream(nums)`

<details>
<summary>정답 보기</summary>

**정답: B) `Arrays.stream(nums)`**

`Arrays.stream()`은 원시 타입 배열에 대해 특화 스트림(`IntStream`)을 반환합니다. `Stream.of(nums)`는 `Stream<int[]>`을 반환하여 배열 자체가 하나의 원소가 됩니다. 배열은 `Collection`이 아니므로 `.stream()` 메서드가 없고, `StreamSupport.stream()`은 `Spliterator`를 인자로 받습니다.
</details>

---

### Q4. [주관식 - 코드] (출처: atomic-integer.md)
`AtomicInteger`의 `compareAndSet`을 사용하여, 현재 값이 `10`일 때만 `0`으로 리셋하는 코드를 한 줄로 작성하세요.

<details>
<summary>정답 보기</summary>

**정답:**
```java
counter.compareAndSet(10, 0);
```

`compareAndSet(expected, update)`는 현재 값이 `expected`와 같을 때만 `update`로 변경하고 `true`를 반환합니다. 다른 스레드가 먼저 값을 변경했다면 `false`를 반환하고 값은 변경되지 않습니다.
</details>

---

### Q5. [주관식 - 단답] (출처: uri-url-encoding-and-resttemplate.md)
`URLEncoder.encode()`는 공백을 어떤 문자로 변환하며, 이것은 어떤 형식의 인코딩 규격을 따르는가?

<details>
<summary>정답 보기</summary>

**정답: `+`로 변환하며, `application/x-www-form-urlencoded` 형식을 따른다.**

이는 URI 표준(RFC 3986)의 `%20`과는 다릅니다. `java.net.URI`는 공백을 `%20`으로 인코딩하지만, `URLEncoder.encode()`는 HTML 폼 전송 규격에 따라 `+`를 사용합니다.
</details>
